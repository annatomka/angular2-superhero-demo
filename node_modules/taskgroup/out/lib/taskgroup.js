// Generated by CoffeeScript 1.6.2
var TaskGroup, ambi, typeChecker,
  __slice = [].slice;

typeChecker = require('typechecker');

ambi = require('ambi');

TaskGroup = (function() {
  _Class.prototype.total = 0;

  _Class.prototype.completed = 0;

  _Class.prototype.running = 0;

  _Class.prototype.exited = false;

  _Class.prototype.breakOnError = true;

  _Class.prototype.autoClear = false;

  _Class.prototype.queue = [];

  _Class.prototype.mode = 'parallel';

  _Class.prototype.lastResult = null;

  _Class.prototype.results = [];

  _Class.prototype.errors = [];

  _Class.prototype.next = function() {
    throw new Error('Groups require a completion callback');
  };

  function _Class() {
    var arg, args, autoClear, breakOnError, mode, next, _i, _len;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    this.clear();
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      if (typeChecker.isString(arg)) {
        if (arg === 'serial' || arg === 'sync') {
          this.mode = 'serial';
        }
      } else if (typeChecker.isFunction(arg)) {
        this.next = arg;
      } else if (typeChecker.isObject(arg)) {
        next = arg.next, mode = arg.mode, breakOnError = arg.breakOnError, autoClear = arg.autoClear;
        if (next) {
          this.next = next;
        }
        if (mode) {
          this.mode = mode;
        }
        if (breakOnError) {
          this.breakOnError = breakOnError;
        }
        if (autoClear) {
          this.autoClear = autoClear;
        }
      } else {
        throw new Error('Unknown argument sent to Groups constructor');
      }
    }
  }

  _Class.prototype.clear = function() {
    this.total = 0;
    this.completed = 0;
    this.running = 0;
    this.exited = false;
    this.queue = [];
    this.results = [];
    this.errors = [];
    this.lastResult = null;
    return this;
  };

  _Class.prototype.hasTasks = function() {
    return this.queue.length !== 0;
  };

  _Class.prototype.hasCompleted = function() {
    return this.total !== 0 && this.total === this.completed;
  };

  _Class.prototype.isRunning = function() {
    return this.running !== 0;
  };

  _Class.prototype.hasExited = function(value) {
    if (value != null) {
      this.exited = value;
    }
    return this.exited === true;
  };

  _Class.prototype.logError = function(err) {
    if (this.errors[this.errors.length - 1] !== err) {
      this.errors.push(err);
    }
    return this;
  };

  _Class.prototype.complete = function() {
    var args, err;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    err = args[0] || void 0;
    this.lastResult = args;
    if (err) {
      this.logError(err);
    }
    this.results.push(args);
    if (this.running !== 0) {
      --this.running;
    }
    if (this.hasExited()) {

    } else {
      if (err && this.breakOnError) {
        this.exit();
      } else {
        ++this.completed;
        if (this.hasTasks()) {
          this.nextTask();
        } else if (this.isRunning() === false && this.hasCompleted()) {
          this.exit();
        }
      }
    }
    return this;
  };

  _Class.prototype.completer = function() {
    var _this = this;

    return function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return _this.complete.apply(_this, args);
    };
  };

  _Class.prototype.exit = function(err) {
    var errors, lastResult, results;

    if (err == null) {
      err = null;
    }
    if (err) {
      this.logError(err);
    }
    if (this.hasExited()) {

    } else {
      lastResult = this.lastResult;
      results = this.results;
      if (this.errors.length === 0) {
        errors = null;
      } else if (this.errors.length === 1) {
        errors = this.errors[0];
      } else {
        errors = this.errors;
      }
      if (this.autoClear) {
        this.clear();
      } else {
        this.hasExited(true);
      }
      this.next(errors, lastResult, results);
    }
    return this;
  };

  _Class.prototype.tasks = function(tasks) {
    var task, _i, _len;

    for (_i = 0, _len = tasks.length; _i < _len; _i++) {
      task = tasks[_i];
      this.push(task);
    }
    return this;
  };

  _Class.prototype.push = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    ++this.total;
    this.queue.push(args);
    return this;
  };

  _Class.prototype.pushAndRun = function() {
    var args;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (this.mode === 'serial' && this.isRunning()) {
      this.push.apply(this, args);
    } else {
      ++this.total;
      this.runTask(args);
    }
    return this;
  };

  _Class.prototype.nextTask = function() {
    var task;

    if (this.hasTasks()) {
      task = this.queue.shift();
      this.runTask(task);
    }
    return this;
  };

  _Class.prototype.runTask = function(task) {
    var err, me, run;

    me = this;
    try {
      run = function() {
        var complete, _task;

        ++me.running;
        complete = me.completer();
        if (typeChecker.isArray(task)) {
          if (task.length === 2) {
            _task = task[1].bind(task[0]);
          } else if (task.length === 1) {
            _task = task[0];
          } else {
            throw new Error('an invalid task was pushed');
          }
        } else {
          _task = task;
        }
        return ambi(_task, complete);
      };
      if (this.completed !== 0 && (this.mode === 'parallel' || (this.completed % 100) === 0)) {
        setTimeout(run, 0);
      } else {
        run();
      }
    } catch (_error) {
      err = _error;
      this.complete(err);
    }
    return this;
  };

  _Class.prototype.run = function(mode) {
    var task, _i, _len, _ref, _ref1;

    if (this.isRunning() === false) {
      if (mode) {
        this.mode = mode;
      }
      this.hasExited(false);
      if (this.hasTasks()) {
        if ((_ref = this.mode) === 'serial' || _ref === 'sync') {
          this.nextTask();
        } else {
          _ref1 = this.queue;
          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
            task = _ref1[_i];
            this.nextTask();
          }
        }
      } else {
        this.exit();
      }
    }
    return this;
  };

  _Class.prototype.async = function() {
    return this.parallel();
  };

  _Class.prototype.parallel = function() {
    this.run('parallel');
    return this;
  };

  _Class.prototype.sync = function() {
    return this.serial();
  };

  _Class.prototype.serial = function() {
    this.run('serial');
    return this;
  };

  return _Class;

})();

module.exports = TaskGroup;
