// Generated by CoffeeScript 1.6.2
var TaskGroup, ambi, balUtilFlow, eachr, extendr, getsetdeep, safeCallback, typeChecker,
  __slice = [].slice,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

typeChecker = require('typechecker');

TaskGroup = require('taskgroup');

getsetdeep = require('getsetdeep');

extendr = require('extendr');

ambi = require('ambi');

eachr = require('eachr');

safeCallback = require('safecallback');

balUtilFlow = extendr.extend({}, extendr, getsetdeep, {
  each: eachr,
  fireWithOptionalCallback: ambi,
  safeCallback: safeCallback,
  wait: function(delay, fn) {
    return setTimeout(fn, delay);
  },
  extractOptsAndCallback: function(opts, next) {
    if (typeChecker.isFunction(opts) && (next != null) === false) {
      next = opts;
      opts = {};
    } else {
      opts || (opts = {});
    }
    next || (next = opts.next || null);
    return [opts, next];
  },
  flow: function() {
    var action, actions, args, next, object, tasks, _ref, _ref1, _ref2;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    if (args.length === 1) {
      _ref = args[0], object = _ref.object, actions = _ref.actions, action = _ref.action, args = _ref.args, tasks = _ref.tasks, next = _ref.next;
    } else if (args.length === 4) {
      _ref1 = args, object = _ref1[0], action = _ref1[1], args = _ref1[2], next = _ref1[3];
    } else if (args.length === 3) {
      _ref2 = args, actions = _ref2[0], args = _ref2[1], next = _ref2[2];
    }
    if ((action != null) === false && (actions != null) === false) {
      throw new Error('balUtilFlow.flow called without any action');
    }
    if (actions == null) {
      actions = action.split(/[,\s]+/g);
    }
    if (object == null) {
      object = global;
    }
    tasks || (tasks = new balUtilFlow.Group(next));
    balUtilFlow.each(actions, function(action) {
      return tasks.push(function(complete) {
        var argsClone, fn;

        argsClone = (args || []).slice();
        argsClone.push(complete);
        fn = typeChecker.isFunction(action) ? action : object[action];
        return fn.apply(object, argsClone);
      });
    });
    tasks.sync();
    return this;
  },
  createSnore: function(message, opts) {
    var snore, _ref;

    opts || (opts = {});
    if ((_ref = opts.delay) == null) {
      opts.delay = 5000;
    }
    snore = {
      snoring: false,
      timer: setTimeout(function() {
        snore.clear();
        snore.snoring = true;
        return typeof message === "function" ? message() : void 0;
      }, opts.delay),
      clear: function() {
        if (snore.timer) {
          clearTimeout(snore.timer);
          return snore.timer = false;
        }
      }
    };
    return snore;
  },
  suffixArray: function() {
    var arg, args, item, result, suffix, _i, _j, _len, _len1;

    suffix = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    result = [];
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      if (!typeChecker.isArray(arg)) {
        arg = [arg];
      }
      for (_j = 0, _len1 = arg.length; _j < _len1; _j++) {
        item = arg[_j];
        result.push(item + suffix);
      }
    }
    return result;
  }
});

balUtilFlow.Group = TaskGroup;

balUtilFlow.Block = (function(_super) {
  __extends(_Class, _super);

  _Class.prototype.blockBefore = function(block) {};

  _Class.prototype.blockAfter = function(block, err) {};

  _Class.prototype.blockTaskBefore = function(block, task, err) {};

  _Class.prototype.blockTaskAfter = function(block, task, err) {};

  function _Class(opts) {
    var block, complete, err, fn, name, parentBlock;

    block = this;
    name = opts.name, fn = opts.fn, parentBlock = opts.parentBlock, complete = opts.complete;
    block.blockName = name;
    if (parentBlock != null) {
      block.parentBlock = parentBlock;
    }
    block.mode = 'sync';
    block.fn = fn;
    _Class.__super__.constructor.call(this, function(err) {
      block.blockAfter(block, err);
      return typeof complete === "function" ? complete(err) : void 0;
    });
    block.blockBefore(block);
    if (block.fn != null) {
      if (block.fn.length === 3) {
        block.total = Infinity;
      }
      try {
        block.fn(function(name, fn) {
          return block.block(name, fn);
        }, function(name, fn) {
          return block.task(name, fn);
        }, function(err) {
          return block.exit(err);
        });
        if (block.fn.length !== 3) {
          block.run();
        }
      } catch (_error) {
        err = _error;
        block.exit(err);
      }
    } else {
      block.total = Infinity;
    }
    this;
  }

  _Class.prototype.block = function(name, fn) {
    var block, pushBlock;

    block = this;
    pushBlock = function(fn) {
      if (block.total === Infinity) {
        return block.pushAndRun(fn);
      } else {
        return block.push(fn);
      }
    };
    pushBlock(function(complete) {
      var subBlock;

      return subBlock = block.createSubBlock({
        name: name,
        fn: fn,
        complete: complete
      });
    });
    return this;
  };

  _Class.prototype.createSubBlock = function(opts) {
    opts.parentBlock = this;
    return new balUtilFlow.Block(opts);
  };

  _Class.prototype.task = function(name, fn) {
    var block, pushTask;

    block = this;
    pushTask = function(fn) {
      if (block.total === Infinity) {
        return block.pushAndRun(fn);
      } else {
        return block.push(fn);
      }
    };
    pushTask(function(complete) {
      var preComplete;

      preComplete = function(err) {
        block.blockTaskAfter(block, name, err);
        return complete(err);
      };
      block.blockTaskBefore(block, name);
      return balUtilFlow.fireWithOptionalCallback(fn, [preComplete]);
    });
    return this;
  };

  return _Class;

})(balUtilFlow.Group);

balUtilFlow.Runner = (function() {
  _Class.prototype.runnerBlock = null;

  function _Class() {
    var _ref;

    if ((_ref = this.runnerBlock) == null) {
      this.runnerBlock = new balUtilFlow.Block();
    }
  }

  _Class.prototype.getRunnerBlock = function() {
    return this.runnerBlock;
  };

  _Class.prototype.block = function() {
    var args, _ref;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return (_ref = this.getRunnerBlock()).block.apply(_ref, args);
  };

  _Class.prototype.task = function() {
    var args, _ref;

    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return (_ref = this.getRunnerBlock()).task.apply(_ref, args);
  };

  return _Class;

})();

module.exports = balUtilFlow;
